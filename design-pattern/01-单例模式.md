# 单例模式

这是设计模式里面最简单的模式，没有之一。

单例的目的，是要让某个类在全局只有一个实例。

## 单例的三个要点

假设提供单例的类是Singleton，那么Singleton有如下要点

1. Singleton拥有private的构造器

构造器不私有，那么会被随便用new来创建其余的实例。

2. Singleton拥有static的实例提供方法

假设现在没有Singleton的实例，需要创建一个，如果创建实例的方法不是static的，就需要用已有的Singleton实例来调用非static的创建实例的方法，然而此时又没有实例，所以实例提供方法必须是static的。

3. Singleton提供的实例必须是static修饰的

实例提供方法是static的，static的方法只能访问static的变量，所以实例必须是static的。

## 单例的实现方式

单例的实现方式众多，典型的有饿汉式单例、懒汉式单例、双重检查锁、静态内部类式以及枚举式单例。

### 饿汉式单例

称为饿汉，是因为该实例在类加载的时候，其静态成员instance就被初始化了，不管之后getInstance方法被调用与否，这个实例都存在了，本写法的优点是简单，缺点是可能存在资源浪费，比如getInstance从没被调用过，这个实例就算是白创建了。

```java
public class Singleton {
  // 静态构造器
  private Singleton() {}

  // static的实例，final可有可无，在类加载的时候就初始化
  private static final Singleton instance = new Singleton();

  // static的提供实例的方法
  public static Singleton getInstance() {
    return instance;
  }
}
```

### 懒汉式单例

之所以成为懒汉，是要在调用提供实例的方法的时候才初始化这个单例的实例。优点是需要的时候才加载，缺点是锁导致的性能问题。

```java
public class Singleton {
  private static Singleton instance;

  private Singleton() {}

  // synchronized确保多线程安全
  public static synchronized Singleton getInstance() { // 多个线程同时访问这里，会大家一起卡在这里，性能堪忧
    if (instance == null) {
      instance = new Singleton();
    }

    return instance;
  }
}
```

### 双重检查锁

其实也是懒汉式，只是针对性能部分做了一点优化

```java
public class Singleton {
  // 注意volatile，该关键字确保所有线程都能正确读取instance的状态
  private static volatile Singleton instance;

  private Singleton() {}

  public static Singleton getInstance() {
    if (instance == null) {
      synchronized (Singleton.class) { // 还是有锁，只不过锁的不是方法，性能也好不到哪里去
        if (instance == null) { // 此处能正确访问到instance的状态，需要归功于volatile关键字
          instance = new Singleton();
        }
      }
    }

    return instance;
  }
}
```

### 占位符式，也称之为静态内部类式

用一个静态内部类保存一个指向Singleton的实例，然后用方法访问该静态内部类。这是比较优秀的一种实现方法，既可以延迟加载，也避免了加锁带来的性能问题。

```java
public class Singleton {
  private Singleton() {}

  // 该静态内部类在Singleton加载的时候并不会加载
  // 而是在getInstance方法调用的时候才会加载
  // 而且由于静态的原因，Singleton自然只有一份实例
  private static class SingletonHolder {
    private static Singleton instance = new Singleton(); // 此处的修饰符可以为private，也可以为public
  }

  public static Singleton getInstance() {
    return SingletonHolder.instance;
  }
}
```

### 枚举式单例

最优秀的单例，枚举天生单例，只是普通人不是很会用枚举而已。

```java
public enum Singleton {
  INSTANCE;
}
```

更详细的写法，实际上，枚举就是类，就是class，就是语法糖，`public enum Singleton`其实就是`public class Singleton extends java.lang.Enum<E extends Enum<E>>`，在一个enum内部可以写静态的，实例的属性和方法，还可以写抽象的方法，把enum当做一个普通类对待就可以了。

```java
public enum Singleton {
  INSTANCE;

  private int status;

  public getStatus() {
    return status;
  }

  public setStatus(int status) {
    this.status = status;
  }
}
```

要获取枚举的单例，只需要Singleton.INSTANCE即可。一般网上写的单例都没写枚举里面的方法，但是枚举里面的方法才是最重要的，是对应单例的操作和状态。


### 单例的安全问题

安全问题主要是两点

1. 多线程访问
2. 反射

上面写的单例都可以抗住多线程，要么用锁要么用了其静态的特性，要么利用了枚举天生单例，但是里面除了枚举，全都扛不住反射。

反射可以把private的构造器改为可访问的，然后就可以调用newInstance来获取对象了，但是枚举就可以避免反射的干扰，因为在调newInstance的时候会抛异常，知道有这个事情就可以了，至于解决，可以通过在普通构造器里面判断一个标志位来解决，如果二次调用了构造器，就抛异常即可。
