# 零散知识

## == equals hashcode

`==`符号用于严格判等，比较对象的时候，比较的是对象的内存地址，`a == b`可以比较出a和b是不是指向内存中同一个对象。

`equals hashcode`都是Object类的方法，只要子类不重写，那么返回的都是对象的内存地址。

`equals`设计之初的目的是用于全面的比较不指向同一个内存地址的两个对象是否相等。比如，有两辆特斯拉，如果他们都是3秒破百，拥有Insane Mode，都是红色车身，黑色高档内饰，19寸运动轮毂，售价都是50W RMB，那么我们就认为这两辆特斯拉是相同的，也就是对象是相等的。但是这种判等，相对来说比较麻烦，因为要比较或者考虑的地方比较多，如果调用比较频繁，那么开销就不太好整。

`hashcode`方法就是用于初步的判定两个对象是否相等，一般来说，对某个对象取某些特征，然后通过一个hash函数，将这些特征计算成一个值，如果两个对象的hashcode不同，那么这俩对象肯定不同，如果相同，那么俩对象有可能相同。

在重写了`equals` `hashcode`方法的时候，就严格程度来说，`==` > `equals` > `hashcode`，`==`返回true的时候，equals方法必须返回true，hashcode方法必须返回相同的hash值。`equals`返回true的时候，hashcode必须返回相同的hash值，但是，两个对象的hash值相同，只能说明他们有可能相同，要进一步的确认两个对象是否相等，还是要调用equals方法来判断。

在使用集合的时候，如果要存自定义对象，那么需要重写对象的equals方法和hashcode方法，确保数据的存入和取出都是正确的。

## java异常体系
* [参考资料](https://www.cnblogs.com/knightsu/p/7114914.html)

## Java线程的退出

一个线程在启动之后，在执行完run方法就会退出，线程就会消亡。但有时候，希望这个线程一直运行，直到满足某些条件再退出，下面介绍一些退出线程的方法。

1. 标志位退出

```java
// 置为volatile很重要，它确保所有线程都可以看到这个变量最新的值
// 但是如果只有一个线程的话，可以不必使用volatile关键字
volatile boolean stop;

new Thread(() -> {
    while (!stop) {
      // 执行任务，当得到需要退出此线程的状态的时候，将stop 置为true
      // 置为true之后，while循环退出，线程run方法执行完毕，线程退出
    }

}).start();
```

2. 接受中断信号退出

线程有一个中断位，当线程收到了送给自己的中断信号的时候，就设置中断位，线程可以告诉你自己是否接收到了中断信号，通过下面的两个方法

* isInterrupted 仅告知用户中断位的状态，不会清除中断位
* interrupted   告知用户中断位的状态，同时清除中断位

当线程被设置中断位的时候，上面的方法都返回true，反之当线程没有被设置中断位的时候，两个方法都返回false。

特别注意interrupted方法，该方法会清除中断位。

如果需要给一个线程发送中断信号，可以调用该线程的interrupt方法。

一个线程收到中断信号只代表它收到了这个信号，这个中断信号代表外界希望它停止自己的执行，但是具体是否停止，还得看该线程怎么处理中断信号，他可以不管这个信号，也可以如其所愿退出线程的执行，结束自己的生命。

```java
new Thread(() -> {
  while (!isInterrupted()) {
    // 在没接收到中断信号的时候做某些事情，当收到中断信号，就会退出
  }
}).start();

new Thread(() -> {
  while (true) {
    try {
        Thread.sleep(1000);
      } catch (InterruptedException e) {
        break; // sleep时接收到中断信号，此时可以选择退出线程
      }
    }
}).start();
```

上面的第二个代码的try写的地方很有讲究，如果将try写在while外面，那么在抛出异常的时候，就会跳到while之外执行，线程自然就退出了，但是需要搞清楚自己的需求，注意写法，因为写法实在是太多了。

* [参考资料](https://www.cnblogs.com/onlywujun/p/3565082.html)

## 代码即数据是什么意思

```java
button.addActionListener(new ActionListener() {
    public void actionPerformed(ActionEvent event) {
      System.out.println("button clicked."); // A
    }
})
```

上面的代码里面，匿名类就是一串代码，他是被当做参数传递给addActionListener方法，这就是代码即数据。

## 函数式接口是什么

函数式接口是只有一个抽象方法的接口，用作lambda表达式的类型。

方法的参数类型如果是一个函数式接口，那么在实际调用这个方法的时候，就可以传入一个与对应函数式接口唯一抽象方法相匹配的lambda表达式。

函数式接口大多数出现在java.util.function这个包下面，可以看到所有的函数式接口都只有一个抽象方法，当然，这个抽象方法可能在父级接口那里。
